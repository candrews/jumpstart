plugins {
	id 'io.spring.dependency-management' version '1.1.0'
	id 'org.springframework.boot' version '3.0.3'
	id 'com.gorylenko.gradle-git-properties' version '2.4.1'
	id 'name.remal.sonarlint' version '3.0.8'
	id 'nebula.lint' version '18.0.3'
	id 'nu.studer.credentials' version '3.0'
	id 'com.github.node-gradle.node' version '3.5.1'
	id 'io.freefair.lombok' version '6.6.3'
	id 'java'
	id 'jacoco'
	id 'eclipse'
}

ext {
	nodeVersion = '19.7.0'
}

group = 'com.integralblue.demo'
version = '0.0.1-SNAPSHOT'

repositories {
	mavenCentral()
}

compileJava {
	options.release = 17
}

dependencies {
	implementation(platform("org.testcontainers:testcontainers-bom:1.17.6"))
	implementation "org.springframework.boot:spring-boot-starter-actuator"
	implementation "org.springframework.boot:spring-boot-starter-data-jpa"
	implementation "org.springframework.boot:spring-boot-starter-security"
	implementation "org.springframework.boot:spring-boot-starter-web"
	implementation "org.springframework.boot:spring-boot-starter-validation"
	implementation "org.springframework.session:spring-session-jdbc"
	implementation "org.liquibase:liquibase-core"

	annotationProcessor "org.springframework.boot:spring-boot-configuration-processor"
	annotationProcessor 'org.springframework:spring-context-indexer'
	annotationProcessor "org.hibernate.validator:hibernate-validator-annotation-processor"

	developmentOnly "org.springframework.boot:spring-boot-devtools"

	testImplementation "org.springframework.boot:spring-boot-starter-test"
	testImplementation "org.springframework.security:spring-security-test"
	testImplementation "org.mockito:mockito-junit-jupiter"
	runtimeOnly 'org.postgresql:postgresql'
	runtimeOnly 'net.lbruun.springboot:preliquibase-spring-boot-starter:1.3.0' // necessary to create the db schema before liquibase runs so liquibase can use the created schema
	testImplementation "org.testcontainers:testcontainers"
	testImplementation "org.testcontainers:junit-jupiter"
	testImplementation 'org.testcontainers:postgresql'
	if (! project.hasProperty('no-testcontainers')) {
		// testcontainers shouldn't be used in an actual, production environment (such as as on running in k8s, aws, etc)
		// this property allows for the exclusion of testcontainers so "real" services can be used instead
		runtimeOnly 'org.testcontainers:postgresql'
	}
}

configurations {
	compileOnly {
		extendsFrom annotationProcessor
	}
}

wrapper {
	distributionType = Wrapper.DistributionType.ALL
}

gradleLint {
	// 'unused-exclude-by-dep' doesn't work with BOM dependency management: https://github.com/nebula-plugins/gradle-lint-plugin/issues/224
	rules  = ['archaic-wrapper']
	criticalRules = [
		'dependency-parentheses',
		'overridden-dependency-version'] // <-- this will fail the build in the event of a violation
}

// reproducible builds
// See: https://candrews.integralblue.com/2020/06/reproducible-builds-in-java/
tasks.withType(AbstractArchiveTask) {
	preserveFileTimestamps = false
	reproducibleFileOrder = true
}

// See: https://candrews.integralblue.com/2022/10/improving-the-reproducibility-of-spring-boots-docker-image-builder/
tasks.named("bootBuildImage") {
	// See: https://paketo.io/docs/howto/java/

	// run the JLink tool and install a minimal JRE for runtime, reducing both image size and attack surface
	environment["BPJVM_JLINK_ENABLED"] = "true"

	docker {
		// version and digest pin all image references. This ensures reproducibility.
		// make sure to configure Renovate to keep these image references up to date.
		// if these image references are not kept up to date, any security issues discovered within them will never be fixed.
		// Use a tiny builder and run image (which produce a distroless-like image) to reduce both image size and attack surface.
		builder = "docker.io/paketobuildpacks/builder-jammy-tiny:0.0.102@sha256:0b4df232a8a6e69ee7c6e933d875192f23191ebd32dd734abcfae0b0ed110705"
		runImage = "docker.io/paketobuildpacks/run-jammy-tiny:0.1.47@sha256:536297bc973136d1faa90be0840ea286efc5f8447d99d0361674dcadb8f5cdc6"
		buildpacks = [
			"gcr.io/paketo-buildpacks/ca-certificates:3.6.0@sha256:cbe105ea53740e4cd81b552b84359da97994b3a731d0a57203d331b5a0366b60",
			"gcr.io/paketo-buildpacks/bellsoft-liberica:9.11.0@sha256:9666234a83efb0915b9ede1d1ebf0c83c016184621a03bed6ea502aba46ea9e5",
			"gcr.io/paketo-buildpacks/syft:1.25.0@sha256:f9458572f79918030857d3705d609556ab17fb2e41b9ebbb195f48d9a93eb76e",
			"gcr.io/paketo-buildpacks/executable-jar:6.6.1@sha256:fae44b5a8552be9a2e0fa834202369d11c46939a6f43a0d9809b94aad99056fe",
			"gcr.io/paketo-buildpacks/dist-zip:5.5.1@sha256:8776a1b5f5604cd0b80b651364397dcfa8e2d8ea3050ed20f46ee44f5f09fbb2",
			"gcr.io/paketo-buildpacks/spring-boot:5.23.0@sha256:fc4d0db457abcb26d13adc74717e3c41ba4186ca4ef3d8d1955c04b1be683cd5",
		]
	}
}

test {
	useJUnitPlatform()
	finalizedBy jacocoTestReport
}

check {
	dependsOn jacocoTestCoverageVerification
}

springBoot {
	buildInfo {
		properties {
			// necessary for reproducible builds, see https://github.com/spring-projects/spring-boot/issues/14494
			time = null
		}
	}
}

bootJar {
	archiveFileName = "${archiveBaseName.get()}.${archiveExtension.get()}" // don't include the version in the artifact jar name
}

jacocoTestReport {
	reports {
		html.required = true
		xml.required = true
	}
}

jacocoTestCoverageVerification {
	violationRules {
		rule {
			limit {
				minimum = 0.10
			}
		}
	}
}

String generatedFrontendResources = "$buildDir/generated-resources"
String frontend = "$projectDir/frontend"

String testsExecutedMarkerName = "${projectDir}/.tests.executed"

node {
	download = true
	version = nodeVersion
	nodeModulesDir = file("${frontend}")
	npmInstallCommand = System.getenv("CI") ? 'ci' : 'install'
}

task nodeDir {
	dependsOn nodeSetup
	println nodeSetup.nodeDir.get()
}

npm_run_build {
	dependsOn npmInstall
	inputs.files fileTree("${frontend}/public")
	inputs.files fileTree("${frontend}/src")
	inputs.file "${frontend}/package.json"
	inputs.file "${frontend}/package-lock.json"
	outputs.dir "${frontend}/build"
}

npm_run_test {
	dependsOn npm_run_build
	setEnvironment CI:"true"
	inputs.files fileTree("${frontend}/public")
	inputs.files fileTree("${frontend}/src")
	inputs.file "${frontend}/package.json"
	inputs.file "${frontend}/package-lock.json"

	// allows easy triggering re-tests
	doLast {
		new File(testsExecutedMarkerName).text = 'delete this file to force re-execution JavaScript tests'
	}
	outputs.file testsExecutedMarkerName
}

task npmCypressVersion(type: NpxTask) {
	dependsOn npmInstall
	command = "cypress"
	args = ["--version"]
}

task npmLighthouseVersion(type: NpxTask) {
	dependsOn npmInstall
	command = "lhci"
	args = ["--version"]
}

task generateFrontendResources(type: Copy) {
	dependsOn npm_run_build
	from "${frontend}/build"
	into "$generatedFrontendResources/static"
	outputs.dir "$generatedFrontendResources"
}

check {
	dependsOn npm_run_test
}

task start {
	dependsOn npm_run_build
	dependsOn 'npm_start'
}

sourceSets {
	main {
		output.dir(generatedFrontendResources, builtBy: generateFrontendResources)
	}
}

clean {
	delete testsExecutedMarkerName
	delete "${frontend}/build"
	delete generatedFrontendResources
}

eclipse {
	autoBuildTasks generateFrontendResources
}

task coverageReport() {
  dependsOn jacocoTestReport

  def reportFile = project.file("build/reports/jacoco/test/jacocoTestReport.xml")
  inputs.file(reportFile)

  doLast {
    def slurper = new XmlSlurper()
    slurper.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false)
    slurper.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false)
    def xml = slurper.parse(reportFile)
    def counter = xml.counter.find {
      node -> node.@type == 'BRANCH'
    }
    double missed = counter.@missed.toDouble() ?: 0
    double covered = counter.@covered.toDouble() ?: 0
    double total = missed + covered ?: 0
    double percentage = (total == 0 ? 100 : (covered / total * 100))

    printf "Missed %.0f branches%n", missed
    printf "Covered %.0f branches%n", covered
    printf "Total %.0f%%%n", percentage
  }
}
jacocoTestReport.finalizedBy coverageReport
