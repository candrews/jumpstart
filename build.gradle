plugins {
	id 'io.spring.dependency-management' version '1.1.0'
	id 'org.springframework.boot' version '3.0.2'
	id 'com.gorylenko.gradle-git-properties' version '2.4.1'
	id 'name.remal.sonarlint' version '3.0.3'
	id 'nebula.lint' version '17.8.0'
	id 'nu.studer.credentials' version '3.0'
	id 'com.github.node-gradle.node' version '3.5.1'
	id 'io.freefair.lombok' version '6.6.1'
	id 'java'
	id 'jacoco'
	id 'eclipse'
}

ext {
	nodeVersion = '19.5.0'
}

group = 'com.integralblue.demo'
version = '0.0.1-SNAPSHOT'

repositories {
	mavenCentral()
}

compileJava {
	options.release = 17
}

dependencies {
	implementation(platform("org.testcontainers:testcontainers-bom:1.17.6"))
	implementation "org.springframework.boot:spring-boot-starter-actuator"
	implementation "org.springframework.boot:spring-boot-starter-data-jpa"
	implementation "org.springframework.boot:spring-boot-starter-security"
	implementation "org.springframework.boot:spring-boot-starter-web"
	implementation "org.springframework.boot:spring-boot-starter-validation"
	implementation "org.springframework.session:spring-session-jdbc"
	implementation "org.liquibase:liquibase-core"

	annotationProcessor "org.springframework.boot:spring-boot-configuration-processor"
	annotationProcessor 'org.springframework:spring-context-indexer'
	annotationProcessor "org.hibernate.validator:hibernate-validator-annotation-processor"

	developmentOnly "org.springframework.boot:spring-boot-devtools"

	testImplementation "org.springframework.boot:spring-boot-starter-test"
	testImplementation "org.springframework.security:spring-security-test"
	testImplementation "org.mockito:mockito-junit-jupiter"
	runtimeOnly 'org.postgresql:postgresql'
	runtimeOnly 'net.lbruun.springboot:preliquibase-spring-boot-starter:1.3.0' // necessary to create the db schema before liquibase runs so liquibase can use the created schema
	testImplementation "org.testcontainers:testcontainers"
	testImplementation "org.testcontainers:junit-jupiter"
	testImplementation 'org.testcontainers:postgresql'
	if (! project.hasProperty('no-testcontainers')) {
		// testcontainers shouldn't be used in an actual, production environment (such as as on running in k8s, aws, etc)
		// this property allows for the exclusion of testcontainers so "real" services can be used instead
		runtimeOnly 'org.testcontainers:postgresql'
	}
}

configurations {
	compileOnly {
		extendsFrom annotationProcessor
	}
}

wrapper {
	distributionType = Wrapper.DistributionType.ALL
}

gradleLint {
	// 'unused-exclude-by-dep' doesn't work with BOM dependency management: https://github.com/nebula-plugins/gradle-lint-plugin/issues/224
	rules  = ['archaic-wrapper']
	criticalRules = [
		'dependency-parentheses',
		'overridden-dependency-version'] // <-- this will fail the build in the event of a violation
}

// reproducible builds
// See: https://candrews.integralblue.com/2020/06/reproducible-builds-in-java/
tasks.withType(AbstractArchiveTask) {
	preserveFileTimestamps = false
	reproducibleFileOrder = true
}

// See: https://candrews.integralblue.com/2022/10/improving-the-reproducibility-of-spring-boots-docker-image-builder/
tasks.named("bootBuildImage") {
	// See: https://paketo.io/docs/howto/java/

	// run the JLink tool and install a minimal JRE for runtime, reducing both image size and attack surface
	environment["BPJVM_JLINK_ENABLED"] = "true"

	docker {
		// version and digest pin all image references. This ensures reproducibility.
		// make sure to configure Renovate to keep these image references up to date.
		// if these image references are not kept up to date, any security issues discovered within them will never be fixed.
		// Use a tiny builder and run image (which produce a distroless-like image) to reduce both image size and attack surface.
		builder = "docker.io/paketobuildpacks/builder-jammy-tiny:0.0.85@sha256:7c4d9608f67729f12ad0c265c2ffd2a17c65535a496c0495038afc1f12bcd0b2"
		runImage = "docker.io/paketobuildpacks/run-jammy-tiny:0.1.39@sha256:b8f333be143cf4eb53de76efa08b91385669063190eedc192a90c65dc80a8c99"
		buildpacks = [
			"gcr.io/paketo-buildpacks/ca-certificates:3.5.1@sha256:ad50eae8fa996f0bb7c85f48135e81121fb1a5f8c9e98cf57703a623e07bd479",
			"gcr.io/paketo-buildpacks/bellsoft-liberica:9.10.2@sha256:58d2a9f5ce67a7799ce3b2ebf11f4a1c880d120c4102d10355722938fbc90538",
			"gcr.io/paketo-buildpacks/syft:1.23.0@sha256:7c77ba8a7dbadc613fba70063ce43b3eeb1b7782424a01bdc60de634075f7d0a",
			"gcr.io/paketo-buildpacks/executable-jar:6.5.0@sha256:971568ae093406911d36fb07c35f589ee69b6c7a2d3f6b90e9e4e924f05baa13",
			"gcr.io/paketo-buildpacks/dist-zip:5.4.0@sha256:245717608ea3a379831ffe9f0a40c0ca82a851c9a0e60f36db9f727cf887f36a",
			"gcr.io/paketo-buildpacks/spring-boot:5.22.1@sha256:734d955907f396075ed6596822d16ecd25b5ca41815045eeb580faa7096d870d",
		]
	}
}

test {
	useJUnitPlatform()
	finalizedBy jacocoTestReport
}

check {
	dependsOn jacocoTestCoverageVerification
}

springBoot {
	buildInfo {
		properties {
			// necessary for reproducible builds, see https://github.com/spring-projects/spring-boot/issues/14494
			time = null
		}
	}
}

bootJar {
	archiveFileName = "${archiveBaseName.get()}.${archiveExtension.get()}" // don't include the version in the artifact jar name
}

jacocoTestReport {
	reports {
		html.enabled true
		xml.enabled true
	}
}

jacocoTestCoverageVerification {
	violationRules {
		rule {
			limit {
				minimum = 0.10
			}
		}
	}
}

String generatedFrontendResources = "$buildDir/generated-resources"
String frontend = "$projectDir/frontend"

String testsExecutedMarkerName = "${projectDir}/.tests.executed"

node {
	download = true
	version = nodeVersion
	nodeModulesDir = file("${frontend}")
	npmInstallCommand = System.getenv("CI") ? 'ci' : 'install'
}

task nodeDir {
	dependsOn nodeSetup
	println nodeSetup.nodeDir.get()
}

npm_run_build {
	dependsOn npmInstall
	inputs.files fileTree("${frontend}/public")
	inputs.files fileTree("${frontend}/src")
	inputs.file "${frontend}/package.json"
	inputs.file "${frontend}/package-lock.json"
	outputs.dir "${frontend}/build"
}

npm_run_test {
	dependsOn npm_run_build
	setEnvironment CI:"true"
	inputs.files fileTree("${frontend}/public")
	inputs.files fileTree("${frontend}/src")
	inputs.file "${frontend}/package.json"
	inputs.file "${frontend}/package-lock.json"

	// allows easy triggering re-tests
	doLast {
		new File(testsExecutedMarkerName).text = 'delete this file to force re-execution JavaScript tests'
	}
	outputs.file testsExecutedMarkerName
}

task npmCypressVersion(type: NpxTask) {
	dependsOn npmInstall
	command = "cypress"
	args = ["--version"]
}

task npmLighthouseVersion(type: NpxTask) {
	dependsOn npmInstall
	command = "lhci"
	args = ["--version"]
}

task generateFrontendResources(type: Copy) {
	dependsOn npm_run_build_build
	from "${frontend}/build"
	into "$generatedFrontendResources/static"
	outputs.dir "$generatedFrontendResources"
}

check {
	dependsOn npm_run_test
}

task start {
	dependsOn npm_run_build
	dependsOn 'npm_start'
}

sourceSets {
	main {
		output.dir(generatedFrontendResources, builtBy: generateFrontendResources)
	}
}

clean {
	delete testsExecutedMarkerName
	delete "${frontend}/build"
	delete generatedFrontendResources
}

eclipse {
	autoBuildTasks generateFrontendResources
}

task coverageReport() {
  dependsOn jacocoTestReport

  def reportFile = project.file("build/reports/jacoco/test/jacocoTestReport.xml")
  inputs.file(reportFile)

  doLast {
    def slurper = new XmlSlurper()
    slurper.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false)
    slurper.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false)
    def xml = slurper.parse(reportFile)
    def counter = xml.counter.find {
      node -> node.@type == 'BRANCH'
    }
    double missed = counter.@missed.toDouble() ?: 0
    double covered = counter.@covered.toDouble() ?: 0
    double total = missed + covered ?: 0
    double percentage = (total == 0 ? 100 : (covered / total * 100))

    printf "Missed %.0f branches%n", missed
    printf "Covered %.0f branches%n", covered
    printf "Total %.0f%%%n", percentage
  }
}
jacocoTestReport.finalizedBy coverageReport
