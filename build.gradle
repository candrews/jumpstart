plugins {
	id 'io.spring.dependency-management' version '1.1.0'
	id 'org.springframework.boot' version '3.1.1'
	id 'com.gorylenko.gradle-git-properties' version '2.4.1'
	id 'name.remal.sonarlint' version '3.2.5'
	id 'nebula.lint' version '18.1.0'
	id 'nu.studer.credentials' version '3.0'
	id 'com.github.node-gradle.node' version '5.0.0'
	id 'io.freefair.lombok' version '8.1.0'
	id 'java'
	id 'jacoco'
	id 'eclipse'
}

ext {
	nodeVersion = '20.3.1'
}

// Remove when using Spring Boot 3.2 or later, as Spring Boot 3.2 will use snakeyaml 2.0: https://github.com/spring-projects/spring-boot/issues/35982
// snakeyaml 2.0 addresses CVE-2022-1471
ext['snakeyaml.version'] = '2.0'

group = 'com.integralblue.demo'
version = '0.0.1-SNAPSHOT'

repositories {
	mavenCentral()
}

compileJava {
	options.release = 17
}


// Enable dependency locking: https://docs.gradle.org/current/userguide/dependency_locking.html
// To achieve reproducible builds, it is necessary to lock versions of dependencies and transitive dependencies such that a build with the same inputs will always resolve the same module versions.
// This is called dependency locking.
// From a security perspective, dependency locking mitigate some supply chain attack risks, as well as provide other benefits.
// From a development/maintainability perspective, dependency locking ensure that dependency changes can only occurs with commits to source control, so all dependency changes are intentional, tracked via the commit history, and enjoy all other change management benefits.
dependencyLocking {
	lockAllConfigurations()
	lockMode = LockMode.STRICT
}

dependencies {
	implementation "org.springframework.boot:spring-boot-starter-actuator"
	implementation "org.springframework.boot:spring-boot-starter-data-jpa"
	implementation "org.springframework.boot:spring-boot-starter-security"
	implementation "org.springframework.boot:spring-boot-starter-web"
	implementation "org.springframework.boot:spring-boot-starter-validation"
	implementation "org.springframework.session:spring-session-jdbc"
	implementation "org.liquibase:liquibase-core"

	annotationProcessor "org.springframework.boot:spring-boot-configuration-processor"
	annotationProcessor 'org.springframework:spring-context-indexer'
	annotationProcessor "org.hibernate.validator:hibernate-validator-annotation-processor"

	developmentOnly "org.springframework.boot:spring-boot-devtools"
	testImplementation "org.springframework.boot:spring-boot-devtools"

	testImplementation "org.springframework.boot:spring-boot-starter-test"
	testImplementation "org.springframework.security:spring-security-test"
	testImplementation "org.mockito:mockito-junit-jupiter"
	runtimeOnly 'org.postgresql:postgresql'
	runtimeOnly 'net.lbruun.springboot:preliquibase-spring-boot-starter:1.4.0' // necessary to create the db schema before liquibase runs so liquibase can use the created schema
	testImplementation "org.testcontainers:testcontainers"
	testImplementation "org.testcontainers:junit-jupiter"
	testImplementation 'org.testcontainers:postgresql'
}

configurations {
	compileOnly {
		extendsFrom annotationProcessor
	}
}

wrapper {
	distributionType = Wrapper.DistributionType.ALL
}

gradleLint {
	// 'unused-exclude-by-dep' doesn't work with BOM dependency management: https://github.com/nebula-plugins/gradle-lint-plugin/issues/224
	rules  = ['archaic-wrapper']
	criticalRules = [
		'dependency-parentheses',
		'overridden-dependency-version'] // <-- this will fail the build in the event of a violation
}

sonarLint {
	sonarProperty('sonar.nodejs.executable', project.provider { "${node.computedNodeDir.get()}/bin/node"}) // configure Node.js executable path via `sonar.nodejs.executable` Sonar property
}

// reproducible builds
// See: https://candrews.integralblue.com/2020/06/reproducible-builds-in-java/
tasks.withType(AbstractArchiveTask) {
	preserveFileTimestamps = false
	reproducibleFileOrder = true
}

// See: https://candrews.integralblue.com/2022/10/improving-the-reproducibility-of-spring-boots-docker-image-builder/
tasks.named("bootBuildImage") {
	// See: https://paketo.io/docs/howto/java/

	docker {
		publishRegistry {
			username = System.env.DOCKER_USERNAME
			password = System.env.DOCKER_PASSWORD
		}

		// version and digest pin all image references. This ensures reproducibility.
		// make sure to configure Renovate to keep these image references up to date.
		// if these image references are not kept up to date, any security issues discovered within them will never be fixed.
		// Use a tiny builder and run image (which produce a distroless-like image) to reduce both image size and attack surface.
		builder = "docker.io/paketobuildpacks/builder-jammy-tiny:0.0.161@sha256:2daca744bbbd9cea3e7671c4d0e678a7a88444ed62f1c228aeaf35311b07b53c"
		runImage = "docker.io/paketobuildpacks/run-jammy-tiny:0.1.69@sha256:13e8d99889ebf5463832201eb64d0397d38aeb3af02740f545a04760ea8c5862"
		buildpacks = [
			"gcr.io/paketo-buildpacks/ca-certificates:3.6.3@sha256:c62529329b8275c1d5b8665fdcee5cd8a92a669133c6b554209f96e8d9c5b632",
			"gcr.io/paketo-buildpacks/bellsoft-liberica:10.2.5@sha256:29d7bbb9d0c9c3df44c21024fc770da824dc76f0bd93db897098279bfb7d420d",
			"gcr.io/paketo-buildpacks/syft:1.32.1@sha256:8c662a749f29523731780a370cf9e1840784ce7ea9675bc2c40b0a6f6ef4c372",
			"gcr.io/paketo-buildpacks/executable-jar:6.7.4@sha256:1b2a80a6f51309785d064172e7032c6543909d5c2c827fd2686b6818f252a25f",
			"gcr.io/paketo-buildpacks/dist-zip:5.6.4@sha256:080303642fa278a8e9b617fb134d7cb9c7959661b03f67913cd5c0d95d6e8534",
			"gcr.io/paketo-buildpacks/spring-boot:5.26.1@sha256:a302dd4444bf204c0ad350384a93221993572e0643c2bb361eb56bac2ef86b6b",
		]
	}
}

test {
	useJUnitPlatform()
	finalizedBy jacocoTestReport
}

check {
	dependsOn jacocoTestCoverageVerification
}

springBoot {
	buildInfo {
		properties {
			// necessary for reproducible builds, see https://github.com/spring-projects/spring-boot/issues/14494
			time = null
		}
	}
}

bootJar {
	archiveFileName = "${archiveBaseName.get()}.${archiveExtension.get()}" // don't include the version in the artifact jar name
}

jacocoTestReport {
	reports {
		html.required = true
		xml.required = true
	}
}

jacocoTestCoverageVerification {
	violationRules {
		rule {
			limit {
				minimum = 0.10
			}
		}
	}
}

String generatedFrontendResources = "$buildDir/generated-resources"
String frontend = "$projectDir/frontend"

String testsExecutedMarkerName = "${projectDir}/.tests.executed"

node {
	download = true
	version = nodeVersion
	nodeModulesDir = file("${frontend}")
	npmInstallCommand = System.getenv("CI") ? 'ci' : 'install'
}

task nodeDir {
	dependsOn nodeSetup
	println node.computedNodeDir.get()
}

npm_run_build {
	dependsOn npmInstall
	inputs.files fileTree("${frontend}/public")
	inputs.files fileTree("${frontend}/src")
	inputs.file "${frontend}/package.json"
	inputs.file "${frontend}/package-lock.json"
	outputs.dir "${frontend}/build"
}

npm_run_test {
	dependsOn npm_run_build
	setEnvironment CI:"true"
	inputs.files fileTree("${frontend}/public")
	inputs.files fileTree("${frontend}/src")
	inputs.file "${frontend}/package.json"
	inputs.file "${frontend}/package-lock.json"

	// allows easy triggering re-tests
	doLast {
		new File(testsExecutedMarkerName).text = 'delete this file to force re-execution JavaScript tests'
	}
	outputs.file testsExecutedMarkerName
}

task npmCypressVersion(type: NpxTask) {
	dependsOn npmInstall
	command = "cypress"
	args = ["--version"]
}

task npmLighthouseVersion(type: NpxTask) {
	dependsOn npmInstall
	command = "lhci"
	args = ["--version"]
}

task generateFrontendResources(type: Copy) {
	dependsOn npm_run_build
	from "${frontend}/build"
	into "$generatedFrontendResources/static"
	outputs.dir "$generatedFrontendResources"
}

check {
	dependsOn npm_run_test
}

task start {
	dependsOn npm_run_build
	dependsOn 'npm_start'
}

sourceSets {
	main {
		output.dir(generatedFrontendResources, builtBy: generateFrontendResources)
	}
}

clean {
	delete testsExecutedMarkerName
	delete "${frontend}/build"
	delete generatedFrontendResources
}

eclipse {
	autoBuildTasks generateFrontendResources
}

task coverageReport() {
  dependsOn jacocoTestReport

  def reportFile = project.file("build/reports/jacoco/test/jacocoTestReport.xml")
  inputs.file(reportFile)

  doLast {
    def slurper = new XmlSlurper()
    slurper.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false)
    slurper.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false)
    def xml = slurper.parse(reportFile)
    def counter = xml.counter.find {
      node -> node.@type == 'BRANCH'
    }
    double missed = counter.@missed.toDouble() ?: 0
    double covered = counter.@covered.toDouble() ?: 0
    double total = missed + covered ?: 0
    double percentage = (total == 0 ? 100 : (covered / total * 100))

    printf "Missed %.0f branches%n", missed
    printf "Covered %.0f branches%n", covered
    printf "Total %.0f%%%n", percentage
  }
}
jacocoTestReport.finalizedBy coverageReport
