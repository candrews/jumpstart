plugins {
	id 'io.spring.dependency-management' version '1.1.0'
	id 'org.springframework.boot' version '3.0.7'
	id 'com.gorylenko.gradle-git-properties' version '2.4.1'
	id 'name.remal.sonarlint' version '3.2.0'
	id 'nebula.lint' version '18.0.3'
	id 'nu.studer.credentials' version '3.0'
	id 'com.github.node-gradle.node' version '4.0.0'
	id 'io.freefair.lombok' version '8.0.1'
	id 'java'
	id 'jacoco'
	id 'eclipse'
}

ext {
	nodeVersion = '20.2.0'
}

group = 'com.integralblue.demo'
version = '0.0.1-SNAPSHOT'

repositories {
	mavenCentral()
}

compileJava {
	options.release = 17
}

dependencies {
	implementation(platform("org.testcontainers:testcontainers-bom:1.18.1"))
	implementation "org.springframework.boot:spring-boot-starter-actuator"
	implementation "org.springframework.boot:spring-boot-starter-data-jpa"
	implementation "org.springframework.boot:spring-boot-starter-security"
	implementation "org.springframework.boot:spring-boot-starter-web"
	implementation "org.springframework.boot:spring-boot-starter-validation"
	implementation "org.springframework.session:spring-session-jdbc"
	implementation "org.liquibase:liquibase-core"

	annotationProcessor "org.springframework.boot:spring-boot-configuration-processor"
	annotationProcessor 'org.springframework:spring-context-indexer'
	annotationProcessor "org.hibernate.validator:hibernate-validator-annotation-processor"

	developmentOnly "org.springframework.boot:spring-boot-devtools"

	testImplementation "org.springframework.boot:spring-boot-starter-test"
	testImplementation "org.springframework.security:spring-security-test"
	testImplementation "org.mockito:mockito-junit-jupiter"
	runtimeOnly 'org.postgresql:postgresql'
	runtimeOnly 'net.lbruun.springboot:preliquibase-spring-boot-starter:1.3.0' // necessary to create the db schema before liquibase runs so liquibase can use the created schema
	testImplementation "org.testcontainers:testcontainers"
	testImplementation "org.testcontainers:junit-jupiter"
	testImplementation 'org.testcontainers:postgresql'
	if (! project.hasProperty('no-testcontainers')) {
		// testcontainers shouldn't be used in an actual, production environment (such as as on running in k8s, aws, etc)
		// this property allows for the exclusion of testcontainers so "real" services can be used instead
		runtimeOnly 'org.testcontainers:postgresql'
	}
}

configurations {
	compileOnly {
		extendsFrom annotationProcessor
	}
}

wrapper {
	distributionType = Wrapper.DistributionType.ALL
}

gradleLint {
	// 'unused-exclude-by-dep' doesn't work with BOM dependency management: https://github.com/nebula-plugins/gradle-lint-plugin/issues/224
	rules  = ['archaic-wrapper']
	criticalRules = [
		'dependency-parentheses',
		'overridden-dependency-version'] // <-- this will fail the build in the event of a violation
}

// reproducible builds
// See: https://candrews.integralblue.com/2020/06/reproducible-builds-in-java/
tasks.withType(AbstractArchiveTask) {
	preserveFileTimestamps = false
	reproducibleFileOrder = true
}

// See: https://candrews.integralblue.com/2022/10/improving-the-reproducibility-of-spring-boots-docker-image-builder/
tasks.named("bootBuildImage") {
	// See: https://paketo.io/docs/howto/java/

	docker {
		// version and digest pin all image references. This ensures reproducibility.
		// make sure to configure Renovate to keep these image references up to date.
		// if these image references are not kept up to date, any security issues discovered within them will never be fixed.
		// Use a tiny builder and run image (which produce a distroless-like image) to reduce both image size and attack surface.
		builder = "docker.io/paketobuildpacks/builder-jammy-tiny:0.0.137@sha256:a6a6d06bc65569e7c6629a88cc47e39a957ca63d66122c966d05c8f1eefc7f5a"
		runImage = "docker.io/paketobuildpacks/run-jammy-tiny:0.1.57@sha256:7c81fe33f85b52e39929b47788d46adf3d531c53442dbc58e9834639f7f62b60"
		buildpacks = [
			"gcr.io/paketo-buildpacks/ca-certificates:3.6.1@sha256:b41cc786c7b844e91360733fcbd0863771c4498a2143da2e500dd08371e25b39",
			"gcr.io/paketo-buildpacks/bellsoft-liberica:10.2.3@sha256:2034cf880d32be33809616400e0e595f6ad18894be43601000b4342fc55ad18c",
			"gcr.io/paketo-buildpacks/syft:1.30.0@sha256:aebf85f97045a796131b2f4098fef511bb4975fbbbeb732c32e937fa479f6701",
			"gcr.io/paketo-buildpacks/executable-jar:6.7.1@sha256:563c96096f8e1be65a159dd120099aa77d7789a23f9a3a75eca64dec5629b9b1",
			"gcr.io/paketo-buildpacks/dist-zip:5.6.1@sha256:956ea6745c5594c139c299815ea88fa20bb8d2f43abe110735e115cae67a5d16",
			"gcr.io/paketo-buildpacks/spring-boot:5.25.0@sha256:7e447069c10408454bcc650895c5ddf1f1bdebb8775b5a10b8fd5f7d4d7809a4",
		]
	}
}

test {
	useJUnitPlatform()
	finalizedBy jacocoTestReport
}

check {
	dependsOn jacocoTestCoverageVerification
}

springBoot {
	buildInfo {
		properties {
			// necessary for reproducible builds, see https://github.com/spring-projects/spring-boot/issues/14494
			time = null
		}
	}
}

bootJar {
	archiveFileName = "${archiveBaseName.get()}.${archiveExtension.get()}" // don't include the version in the artifact jar name
}

jacocoTestReport {
	reports {
		html.required = true
		xml.required = true
	}
}

jacocoTestCoverageVerification {
	violationRules {
		rule {
			limit {
				minimum = 0.10
			}
		}
	}
}

String generatedFrontendResources = "$buildDir/generated-resources"
String frontend = "$projectDir/frontend"

String testsExecutedMarkerName = "${projectDir}/.tests.executed"

node {
	download = true
	version = nodeVersion
	nodeModulesDir = file("${frontend}")
	npmInstallCommand = System.getenv("CI") ? 'ci' : 'install'
}

task nodeDir {
	dependsOn nodeSetup
	println nodeSetup.nodeDir.get()
}

npm_run_build {
	dependsOn npmInstall
	inputs.files fileTree("${frontend}/public")
	inputs.files fileTree("${frontend}/src")
	inputs.file "${frontend}/package.json"
	inputs.file "${frontend}/package-lock.json"
	outputs.dir "${frontend}/build"
}

npm_run_test {
	dependsOn npm_run_build
	setEnvironment CI:"true"
	inputs.files fileTree("${frontend}/public")
	inputs.files fileTree("${frontend}/src")
	inputs.file "${frontend}/package.json"
	inputs.file "${frontend}/package-lock.json"

	// allows easy triggering re-tests
	doLast {
		new File(testsExecutedMarkerName).text = 'delete this file to force re-execution JavaScript tests'
	}
	outputs.file testsExecutedMarkerName
}

task npmCypressVersion(type: NpxTask) {
	dependsOn npmInstall
	command = "cypress"
	args = ["--version"]
}

task npmLighthouseVersion(type: NpxTask) {
	dependsOn npmInstall
	command = "lhci"
	args = ["--version"]
}

task generateFrontendResources(type: Copy) {
	dependsOn npm_run_build
	from "${frontend}/build"
	into "$generatedFrontendResources/static"
	outputs.dir "$generatedFrontendResources"
}

check {
	dependsOn npm_run_test
}

task start {
	dependsOn npm_run_build
	dependsOn 'npm_start'
}

sourceSets {
	main {
		output.dir(generatedFrontendResources, builtBy: generateFrontendResources)
	}
}

clean {
	delete testsExecutedMarkerName
	delete "${frontend}/build"
	delete generatedFrontendResources
}

eclipse {
	autoBuildTasks generateFrontendResources
}

task coverageReport() {
  dependsOn jacocoTestReport

  def reportFile = project.file("build/reports/jacoco/test/jacocoTestReport.xml")
  inputs.file(reportFile)

  doLast {
    def slurper = new XmlSlurper()
    slurper.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false)
    slurper.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false)
    def xml = slurper.parse(reportFile)
    def counter = xml.counter.find {
      node -> node.@type == 'BRANCH'
    }
    double missed = counter.@missed.toDouble() ?: 0
    double covered = counter.@covered.toDouble() ?: 0
    double total = missed + covered ?: 0
    double percentage = (total == 0 ? 100 : (covered / total * 100))

    printf "Missed %.0f branches%n", missed
    printf "Covered %.0f branches%n", covered
    printf "Total %.0f%%%n", percentage
  }
}
jacocoTestReport.finalizedBy coverageReport
